<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>J-Nita v5.0 - Web-Based OCR Pipeline</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: radial-gradient(circle at top, #f5f7ff 0%, #eef1f7 40%, #e7ebf4 100%);
            min-height: 100vh;
            padding: 24px;
            color: #1d2433;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #ffffff;
            border-radius: 20px;
            box-shadow: 0 24px 80px rgba(15, 23, 42, 0.12);
            overflow: hidden;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .header {
            background: linear-gradient(120deg, #111827 0%, #1f2937 50%, #0f172a 100%);
            color: white;
            padding: 34px 40px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 16px;
        }

        .header h1 {
            font-size: 2.1em;
            margin-bottom: 6px;
            letter-spacing: -0.02em;
        }

        .header p {
            opacity: 0.8;
            font-size: 1.05em;
            max-width: 640px;
        }

        .header-meta {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end;
        }

        .status-pill {
            background: rgba(255, 255, 255, 0.12);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 6px 14px;
            border-radius: 999px;
            font-size: 0.85em;
        }

        .panel-actions .status-pill {
            background: #eef2ff;
            color: #4338ca;
            border: 1px solid #c7d2fe;
        }

        .content {
            padding: 32px 40px 40px;
        }

        /* Image Processing Section */
        .processing-section {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .image-panel {
            border: 1px solid #e2e8f0;
            border-radius: 14px;
            padding: 16px 16px 18px;
            background: #f8fafc;
            display: flex;
            flex-direction: column;
            gap: 12px;
            position: relative;
        }

        .image-panel h3 {
            margin-bottom: 0;
            color: #1f2937;
            text-align: left;
            font-size: 1.05em;
            font-weight: 700;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .panel-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .canvas-container {
            width: 100%;
            height: 400px;
            border: 1px dashed #cbd5f5;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(160deg, #fdfdff 0%, #f1f5ff 100%);
            position: relative;
            overflow: hidden;
        }

        .canvas-container canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .canvas-container .placeholder {
            color: #94a3b8;
            text-align: center;
            padding: 20px;
            font-size: 0.95em;
        }

        .progress-overlay {
            position: absolute;
            inset: 0;
            background: rgba(248, 250, 252, 0.92);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 18px;
            text-align: left;
            color: #1f2937;
            backdrop-filter: blur(6px);
        }

        .progress-overlay.active {
            display: flex;
        }

        .progress-log {
            width: 100%;
            max-height: 320px;
            overflow-y: auto;
            font-size: 0.9em;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .progress-line {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            border-radius: 8px;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            box-shadow: 0 6px 20px rgba(15, 23, 42, 0.06);
        }

        .progress-line.complete {
            border-color: #86efac;
            background: #f0fdf4;
        }

        .progress-line.error {
            border-color: #fecaca;
            background: #fef2f2;
        }

        .progress-icon {
            font-size: 0.95em;
        }

        .progress-message {
            flex: 1;
        }

        .upload-area {
            border: 2px dashed #94a3ff;
            border-radius: 16px;
            padding: 34px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: linear-gradient(140deg, #f5f7ff 0%, #eff3ff 100%);
            margin-bottom: 24px;
        }

        .upload-area:hover {
            background: #e8edff;
            border-color: #764ba2;
        }

        .upload-area.dragover {
            background: #dde5ff;
            border-color: #667eea;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #ffffff;
            color: #1f2937;
            border: 1px solid #cbd5f5;
        }

        .btn-secondary:hover {
            background: #f1f5ff;
        }

        .btn-ghost {
            background: transparent;
            color: #4b5563;
            border: 1px solid #e2e8f0;
            padding: 8px 16px;
        }

        .btn-ghost:hover {
            background: #f8fafc;
        }

        .text-output {
            min-height: 400px;
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 16px;
            background: #ffffff;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            position: relative;
        }

        .text-content.empty {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-style: italic;
        }

        .text-content {
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .alert {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            display: none;
        }

        .alert.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .alert.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .description {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 8px;
        }

        /* Configuration Section */
        .section {
            margin-bottom: 20px;
            border: 1px solid #e2e8f0;
            border-radius: 14px;
            overflow: hidden;
            background: #ffffff;
        }

        .section-header {
            background: #f8fafc;
            padding: 16px 20px;
            font-size: 1.05em;
            font-weight: 700;
            color: #1f2937;
            border-bottom: 1px solid #e2e8f0;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .section-header:hover {
            background: #eef2ff;
        }

        .section-content {
            padding: 20px;
            display: none;
        }

        .section-content.active {
            display: block;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        .form-group input[type="text"],
        .form-group input[type="number"],
        .form-group select {
            width: 100%;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 0.95em;
        }

        .form-group input[type="range"] {
            width: 100%;
        }

        .range-value {
            display: inline-block;
            margin-left: 10px;
            font-weight: 600;
            color: #667eea;
        }

        .model-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .model-card {
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s;
            background: #ffffff;
        }

        .model-card:hover {
            border-color: #667eea;
        }

        .model-card.selected {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .model-card.primary {
            border-color: #4caf50;
            background: #f1f8f4;
        }

        .actions {
            text-align: center;
            margin-top: 10px;
        }

        .advanced-panel {
            margin-top: 16px;
            padding: 14px;
            border-radius: 12px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            display: none;
        }

        .advanced-panel.active {
            display: block;
        }

        .advanced-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }

        .advanced-card {
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 10px;
            background: #ffffff;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .advanced-card h4 {
            font-size: 0.9em;
            color: #475569;
        }

        .advanced-canvas {
            width: 100%;
            height: 140px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
        }

        @media (max-width: 1200px) {
            .processing-section {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div>
                <h1>J-Nita v5.0 OCR Studio</h1>
                <p>Professional-grade image conditioning and OCR extraction with guided stages and live status.</p>
            </div>
            <div class="header-meta">
                <span class="status-pill">Backend: https://j-nita.onrender.com</span>
                <span class="status-pill">Pipeline: Conditioning ‚Üí OCR</span>
            </div>
        </div>

        <div class="content">
            <div class="alert success" id="successAlert"></div>
            <div class="alert error" id="errorAlert"></div>
            <div class="alert info" id="infoAlert"></div>

            <!-- Image Upload -->
            <div class="upload-area" id="uploadArea">
                <input type="file" id="fileInput" accept="image/*" style="display: none;">
                <h3>Upload an image to begin</h3>
                <p>Drag & drop or click to select a file for conditioning and OCR.</p>
                <p style="font-size: 0.9em; color: #64748b;">Supports PNG, JPG, JPEG, BMP, TIFF, WEBP</p>
            </div>

            <!-- Processing Section -->
            <div class="processing-section">
                <!-- Original Image -->
                <div class="image-panel">
                    <div class="panel-header">
                        <h3>Original Image</h3>
                        <div class="panel-actions">
                            <span class="status-pill">Input</span>
                        </div>
                    </div>
                    <div class="canvas-container">
                        <canvas id="originalCanvas"></canvas>
                        <div class="placeholder" id="originalPlaceholder">No image uploaded</div>
                    </div>
                </div>

                <!-- Conditioned Image -->
                <div class="image-panel">
                    <div class="panel-header">
                        <h3>Conditioned Image</h3>
                        <div class="panel-actions">
                            <button class="btn btn-ghost" id="advancedToggle" disabled>Advanced</button>
                        </div>
                    </div>
                    <div class="canvas-container">
                        <canvas id="conditionedCanvas"></canvas>
                        <div class="placeholder" id="conditionedPlaceholder">Will appear after conditioning</div>
                        <div class="progress-overlay" id="conditionOverlay">
                            <div class="progress-log" id="conditionLog"></div>
                        </div>
                    </div>
                    <div class="advanced-panel" id="advancedPanel">
                        <div class="advanced-grid">
                            <div class="advanced-card">
                                <h4>Corner Detection</h4>
                                <canvas id="boundingCanvas" class="advanced-canvas"></canvas>
                            </div>
                            <div class="advanced-card">
                                <h4>Smart Crop</h4>
                                <canvas id="cropCanvas" class="advanced-canvas"></canvas>
                            </div>
                            <div class="advanced-card">
                                <h4>Filter Pass</h4>
                                <canvas id="filterCanvas" class="advanced-canvas"></canvas>
                            </div>
                            <div class="advanced-card">
                                <h4>Final Conditioned</h4>
                                <canvas id="finalCanvas" class="advanced-canvas"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- OCR Results -->
                <div class="image-panel">
                    <div class="panel-header">
                        <h3>OCR Results</h3>
                        <div class="panel-actions">
                            <span class="status-pill">Text Output</span>
                        </div>
                    </div>
                    <div class="text-output" id="textOutput">
                        <div class="text-content empty" id="textContent">Text will appear here after OCR processing</div>
                        <div class="progress-overlay" id="ocrOverlay">
                            <div class="progress-log" id="ocrLog"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="actions">
                <button class="btn btn-primary" id="conditionBtn" disabled>üñºÔ∏è Condition Image</button>
                <button class="btn btn-primary" id="ocrBtn" disabled>üîç Run OCR</button>
                <button class="btn btn-secondary" id="resetBtn">üîÑ Reset</button>
            </div>

            <!-- Configuration Section -->
            <div class="section">
                <div class="section-header" onclick="toggleSection(this)">
                    <span>‚öôÔ∏è OCR Configuration</span>
                    <span>‚ñº</span>
                </div>
                <div class="section-content" id="configSection">
                    <!-- OCR Model Selection -->
                    <div class="form-group">
                        <label>Primary OCR Model</label>
                        <select id="ocr_model">
                            <option value="Nanonets-OCR2-3B">Nanonets-OCR2-3B (High Quality)</option>
                            <option value="Chandra-OCR">Chandra-OCR (Medium Quality)</option>
                            <option value="Dots.OCR">Dots.OCR (Medium Quality)</option>
                            <option value="olmOCR-2-7B-1025">olmOCR-2-7B-1025 (High Quality, Slow)</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Fallback Models</label>
                        <div class="model-selector" id="fallbackModels">
                            <div class="model-card" data-model="Nanonets-OCR2-3B">Nanonets-OCR2-3B</div>
                            <div class="model-card" data-model="Chandra-OCR">Chandra-OCR</div>
                            <div class="model-card" data-model="Dots.OCR">Dots.OCR</div>
                            <div class="model-card" data-model="olmOCR-2-7B-1025">olmOCR-2-7B-1025</div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>Conditioning Strength</label>
                        <input type="range" id="strength" min="0" max="100" value="10" oninput="updateRangeValue(this)">
                        <span class="range-value" id="strength_value">10</span>
                    </div>

                    <div class="form-group">
                        <label>PNG Compression</label>
                        <input type="range" id="png_compression" min="0" max="9" value="0" oninput="updateRangeValue(this)">
                        <span class="range-value" id="png_compression_value">0</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'https://j-nita.onrender.com';
        let currentImage = null;
        let conditionedImage = null;
        let originalImageElement = null;
        let conditionedImageElement = null;
        let backendWarmed = false;

        // Initialize
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
        document.getElementById('uploadArea').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('uploadArea').addEventListener('dragover', handleDragOver);
        document.getElementById('uploadArea').addEventListener('drop', handleDrop);
        document.getElementById('conditionBtn').addEventListener('click', conditionImage);
        document.getElementById('ocrBtn').addEventListener('click', processOCR);
        document.getElementById('resetBtn').addEventListener('click', resetAll);
        document.getElementById('advancedToggle').addEventListener('click', toggleAdvancedPanel);

        // Model card selection
        document.querySelectorAll('.model-card').forEach(card => {
            card.addEventListener('click', function() {
                const primaryModel = document.getElementById('ocr_model').value;
                if (this.dataset.model !== primaryModel) {
                    this.classList.toggle('selected');
                }
            });
        });

        document.getElementById('ocr_model').addEventListener('change', updatePrimaryModel);
        updatePrimaryModel();

        function drawImageToCanvas(img, canvas, options = {}) {
            const ctx = canvas.getContext('2d');
            let maxWidth = options.maxWidth || canvas.parentElement.clientWidth - 30;
            let maxHeight = options.maxHeight || canvas.parentElement.clientHeight - 30;
            if (maxWidth <= 0) maxWidth = canvas.clientWidth || 320;
            if (maxHeight <= 0) maxHeight = canvas.clientHeight || 240;
            const ratio = Math.min(maxWidth / img.width, maxHeight / img.height);
            const width = img.width * ratio;
            const height = img.height * ratio;
            const offsetX = (maxWidth - width) / 2;
            const offsetY = (maxHeight - height) / 2;

            canvas.width = maxWidth;
            canvas.height = maxHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, offsetX, offsetY, width, height);

            return { ctx, width, height, offsetX, offsetY, scale: ratio };
        }

        function createLogLine(container, message) {
            const line = document.createElement('div');
            line.className = 'progress-line';
            line.innerHTML = `<span class="progress-icon">‚è≥</span><span class="progress-message">${message}</span>`;
            container.appendChild(line);
            container.scrollTop = container.scrollHeight;
            return line;
        }

        function markLogLine(line, status, message) {
            const icon = line.querySelector('.progress-icon');
            const text = line.querySelector('.progress-message');
            if (status === 'complete') {
                line.classList.add('complete');
                icon.textContent = '‚úÖ';
            } else if (status === 'error') {
                line.classList.add('error');
                icon.textContent = '‚ö†Ô∏è';
            } else {
                icon.textContent = '‚è≥';
            }
            if (message) {
                text.textContent = message;
            }
        }

        function showOverlay(overlayId) {
            const overlay = document.getElementById(overlayId);
            overlay.classList.add('active');
        }

        function hideOverlay(overlayId) {
            const overlay = document.getElementById(overlayId);
            overlay.classList.remove('active');
        }

        async function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function fetchWithTimeout(resource, options = {}, timeoutMs = 4000) {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), timeoutMs);
            try {
                return await fetch(resource, { ...options, signal: controller.signal });
            } finally {
                clearTimeout(timeout);
            }
        }

        async function warmBackend(container) {
            if (backendWarmed) {
                return true;
            }
            const line = createLogLine(container, 'Waking backend (cold start on Render)');
            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    markLogLine(line, 'pending', `Waking backend (attempt ${attempt}/3)`);
                    const response = await fetchWithTimeout(`${API_BASE}/api/health`, { cache: 'no-store' }, 5000);
                    if (response.ok) {
                        backendWarmed = true;
                        markLogLine(line, 'complete', 'Backend is awake and responding.');
                        return true;
                    }
                } catch (error) {
                    markLogLine(line, 'pending', 'Waiting for backend response...');
                    await wait(1200);
                }
            }
            markLogLine(line, 'error', 'Backend is still waking up. Continuing with request.');
            return false;
        }

        async function runStage(container, message, delay = 650) {
            const line = createLogLine(container, message);
            await wait(delay);
            markLogLine(line, 'complete');
            return line;
        }

        async function waitForPromiseWithUpdates(container, promise, message) {
            const line = createLogLine(container, message);
            let resolved = false;
            while (!resolved) {
                try {
                    const result = await Promise.race([promise, wait(1200)]);
                    if (result !== undefined) {
                        resolved = true;
                        markLogLine(line, 'complete', 'Backend response received.');
                        return result;
                    }
                    markLogLine(line, 'pending', 'Waiting for backend response...');
                } catch (error) {
                    markLogLine(line, 'error', 'Backend request failed.');
                    throw error;
                }
            }
            return await promise;
        }

        function updatePrimaryModel() {
            const primaryModel = document.getElementById('ocr_model').value;
            document.querySelectorAll('.model-card').forEach(card => {
                card.classList.remove('primary', 'selected');
                if (card.dataset.model === primaryModel) {
                    card.classList.add('primary');
                }
            });
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.add('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        }

        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                showAlert('error', 'Please upload an image file');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    currentImage = e.target.result;
                    originalImageElement = img;
                    displayImage(img, 'originalCanvas', 'originalPlaceholder');
                    document.getElementById('conditionBtn').disabled = false;
                    document.getElementById('ocrBtn').disabled = true;
                    document.getElementById('conditionedPlaceholder').style.display = 'block';
                    const textContent = document.getElementById('textContent');
                    textContent.textContent = 'Text will appear here after OCR processing';
                    textContent.classList.add('empty');
                    resetAdvancedPanel();
                    hideOverlay('conditionOverlay');
                    hideOverlay('ocrOverlay');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function displayImage(img, canvasId, placeholderId) {
            const canvas = document.getElementById(canvasId);
            const placeholder = document.getElementById(placeholderId);
            placeholder.style.display = 'none';
            canvas.style.display = 'block';

            drawImageToCanvas(img, canvas, {
                maxWidth: canvas.parentElement.clientWidth - 30,
                maxHeight: 400
            });
        }

        async function conditionImage() {
            if (!currentImage) {
                showAlert('error', 'Please upload an image first');
                return;
            }

            const btn = document.getElementById('conditionBtn');
            btn.disabled = true;
            btn.innerHTML = '<span class="loading"></span> Conditioning...';

            const logContainer = document.getElementById('conditionLog');
            logContainer.innerHTML = '';
            showOverlay('conditionOverlay');
            document.getElementById('conditionedPlaceholder').style.display = 'none';
            document.getElementById('conditionedCanvas').style.display = 'none';
            resetAdvancedPanel();

            try {
                const strength = parseInt(document.getElementById('strength').value);
                const compression = parseInt(document.getElementById('png_compression').value);

                await warmBackend(logContainer);

                const requestPromise = fetch(`${API_BASE}/api/condition`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image: currentImage,
                        config: {
                            strength: strength,
                            png_compression: compression
                        }
                    })
                });

                const stages = [
                    'Validating orientation and metadata',
                    'Detecting page edges and corners',
                    'Estimating bounding box geometry',
                    'Cropping to the document region',
                    'Resizing for OCR clarity',
                    'Applying denoise + adaptive threshold',
                    'Refining strokes with morphology'
                ];

                for (const stage of stages) {
                    await runStage(logContainer, stage, 520);
                }

                const response = await waitForPromiseWithUpdates(
                    logContainer,
                    requestPromise,
                    'Waiting for backend response'
                );

                if (!response.ok) {
                    throw new Error(`Backend responded with ${response.status}`);
                }

                const data = await response.json();

                if (data.success) {
                    conditionedImage = data.conditioned_image;
                    const img = new Image();
                    img.onload = function() {
                        conditionedImageElement = img;
                        displayImage(img, 'conditionedCanvas', 'conditionedPlaceholder');
                        document.getElementById('ocrBtn').disabled = false;
                        document.getElementById('advancedToggle').disabled = false;
                        renderAdvancedCanvases();
                        hideOverlay('conditionOverlay');
                        showAlert('success', 'Image conditioned successfully!');
                    };
                    img.src = data.conditioned_image;
                } else {
                    const line = createLogLine(logContainer, 'Conditioning failed');
                    markLogLine(line, 'error', data.error || 'Failed to condition image');
                    showAlert('error', data.error || 'Failed to condition image');
                }
            } catch (error) {
                const line = createLogLine(logContainer, 'Conditioning failed');
                markLogLine(line, 'error', `Error: ${error.message}`);
                showAlert('error', 'Error: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'üñºÔ∏è Condition Image';
            }
        }

        async function processOCR() {
            if (!conditionedImage) {
                showAlert('error', 'Please condition the image first');
                return;
            }

            const btn = document.getElementById('ocrBtn');
            btn.disabled = true;
            btn.innerHTML = '<span class="loading"></span> Processing OCR...';

            const logContainer = document.getElementById('ocrLog');
            logContainer.innerHTML = '';
            showOverlay('ocrOverlay');
            const textContent = document.getElementById('textContent');
            textContent.textContent = 'OCR running...';
            textContent.classList.add('empty');

            try {
                const model = document.getElementById('ocr_model').value;
                const fallbackModels = Array.from(document.querySelectorAll('.model-card.selected'))
                    .map(card => card.dataset.model);

                await warmBackend(logContainer);

                const requestPromise = fetch(`${API_BASE}/api/ocr`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image: conditionedImage,
                        model: model,
                        fallback_models: fallbackModels,
                        enable_fallback: fallbackModels.length > 0
                    })
                });

                const stages = [
                    'Preparing OCR payload',
                    `Selecting model: ${model}`,
                    'Submitting request to OCR engine',
                    'Running text extraction',
                    'Normalizing response format'
                ];

                for (const stage of stages) {
                    await runStage(logContainer, stage, 520);
                }

                const response = await waitForPromiseWithUpdates(
                    logContainer,
                    requestPromise,
                    'Waiting for OCR response'
                );

                if (!response.ok) {
                    throw new Error(`Backend responded with ${response.status}`);
                }

                const data = await response.json();

                if (data.success) {
                    const textContent = document.getElementById('textContent');
                    textContent.textContent = data.raw_text || data.markdown_text || 'No text extracted';
                    textContent.classList.remove('empty');
                    hideOverlay('ocrOverlay');
                    showAlert('success', `OCR completed using model: ${data.model_used}`);
                } else {
                    const line = createLogLine(logContainer, 'OCR failed');
                    markLogLine(line, 'error', data.error || 'OCR processing failed');
                    showAlert('error', data.error || 'OCR processing failed');
                }
            } catch (error) {
                const line = createLogLine(logContainer, 'OCR failed');
                markLogLine(line, 'error', `Error: ${error.message}`);
                showAlert('error', 'Error: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'üîç Run OCR';
            }
        }

        function toggleAdvancedPanel() {
            const panel = document.getElementById('advancedPanel');
            panel.classList.toggle('active');
            const button = document.getElementById('advancedToggle');
            button.textContent = panel.classList.contains('active') ? 'Hide Advanced' : 'Advanced';
        }

        function resetAdvancedPanel() {
            const panel = document.getElementById('advancedPanel');
            panel.classList.remove('active');
            document.getElementById('advancedToggle').disabled = true;
            document.getElementById('advancedToggle').textContent = 'Advanced';
        }

        function renderAdvancedCanvases() {
            if (!originalImageElement || !conditionedImageElement) {
                return;
            }

            renderBoundingBox(originalImageElement);
            renderCropPreview(originalImageElement);
            renderFilterPreview(originalImageElement);
            renderFinalPreview(conditionedImageElement);
        }

        function renderBoundingBox(img) {
            const canvas = document.getElementById('boundingCanvas');
            const { ctx, width, height, offsetX, offsetY } = drawImageToCanvas(img, canvas, {
                maxWidth: canvas.clientWidth,
                maxHeight: canvas.clientHeight
            });
            ctx.strokeStyle = '#6366f1';
            ctx.lineWidth = 2;
            const insetX = width * 0.08;
            const insetY = height * 0.08;
            ctx.strokeRect(offsetX + insetX, offsetY + insetY, width - insetX * 2, height - insetY * 2);
        }

        function renderCropPreview(img) {
            const canvas = document.getElementById('cropCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            canvas.width = width;
            canvas.height = height;

            const cropWidth = img.width * 0.8;
            const cropHeight = img.height * 0.8;
            const sx = (img.width - cropWidth) / 2;
            const sy = (img.height - cropHeight) / 2;
            ctx.clearRect(0, 0, width, height);
            ctx.drawImage(img, sx, sy, cropWidth, cropHeight, 0, 0, width, height);
        }

        function renderFilterPreview(img) {
            const canvas = document.getElementById('filterCanvas');
            const { ctx } = drawImageToCanvas(img, canvas, {
                maxWidth: canvas.clientWidth,
                maxHeight: canvas.clientHeight
            });
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                const boost = avg > 170 ? 255 : avg * 0.9;
                data[i] = boost;
                data[i + 1] = boost;
                data[i + 2] = boost;
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function renderFinalPreview(img) {
            const canvas = document.getElementById('finalCanvas');
            drawImageToCanvas(img, canvas, {
                maxWidth: canvas.clientWidth,
                maxHeight: canvas.clientHeight
            });
        }

        function clearCanvas(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function resetAll() {
            currentImage = null;
            conditionedImage = null;
            originalImageElement = null;
            conditionedImageElement = null;
            document.getElementById('originalCanvas').style.display = 'none';
            document.getElementById('conditionedCanvas').style.display = 'none';
            document.getElementById('originalPlaceholder').style.display = 'block';
            document.getElementById('conditionedPlaceholder').style.display = 'block';
            const textContent = document.getElementById('textContent');
            textContent.textContent = 'Text will appear here after OCR processing';
            textContent.classList.add('empty');
            document.getElementById('conditionBtn').disabled = true;
            document.getElementById('ocrBtn').disabled = true;
            document.getElementById('fileInput').value = '';
            resetAdvancedPanel();
            hideOverlay('conditionOverlay');
            hideOverlay('ocrOverlay');
            clearCanvas('boundingCanvas');
            clearCanvas('cropCanvas');
            clearCanvas('filterCanvas');
            clearCanvas('finalCanvas');
            document.getElementById('conditionLog').innerHTML = '';
            document.getElementById('ocrLog').innerHTML = '';
        }

        function showAlert(type, message) {
            const alert = document.getElementById(type + 'Alert');
            if (alert) {
                alert.textContent = message;
                alert.style.display = 'block';
                setTimeout(() => {
                    alert.style.display = 'none';
                }, 5000);
            }
        }

        function toggleSection(header) {
            const content = header.nextElementSibling;
            const arrow = header.querySelector('span:last-child');
            content.classList.toggle('active');
            arrow.textContent = content.classList.contains('active') ? '‚ñº' : '‚ñ∂';
        }

        function updateRangeValue(input) {
            const valueSpan = document.getElementById(input.id + '_value');
            if (valueSpan) {
                valueSpan.textContent = input.value;
            }
        }

    </script>
</body>
</html>